"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class NestError extends Error {
}
let typeNameRunning = false;
function getTypeName(value, nest = 0) {
    if (nest === 0 && typeNameRunning) {
        throw new NestError('Called getTypeName() while it was already running');
    }
    typeNameRunning = true;
    try {
        if (nest === 5) {
            throw new NestError('NestError');
        }
        if (value === null) {
            return 'null';
        }
        if (['undefined', 'number', 'string', 'boolean'].indexOf(typeof value) >= 0) {
            return typeof value;
        }
        if (value instanceof Array) {
            const itemTypes = Array.from(new Set(value.map((v) => getTypeName(v, nest + 1)))).filter((t) => t !== null);
            if (itemTypes.length === 0) {
                return null;
            }
            if (itemTypes.length === 1) {
                return itemTypes[0] + '[]';
            }
            return `Array<${itemTypes.sort().join('|')}>`;
        }
        if (value instanceof Function) {
            const result = getFunctionType(value);
            if (result) {
                return result;
            }
        }
        if (value.constructor && value.constructor.name) {
            const { name } = value.constructor;
            if (name === 'Object') {
                return getObjectTypes(value, nest);
            }
            else {
                return name;
            }
        }
        return typeof value;
    }
    finally {
        if (nest === 0) {
            typeNameRunning = false;
        }
    }
}
exports.getTypeName = getTypeName;
function getFunctionType(value) {
    let argsStr = '';
    try {
        argsStr = value.toString().split('=>')[0];
    }
    catch (err) {
        // toString() could throw an error
        return 'Function';
    }
    // make sure argsStr is in a form of (arg1,arg2) for the following cases
    // fn = a => 3
    // fn = (a) => 3
    // function fn(a) { return 3 }
    argsStr = argsStr.includes('(') ? (argsStr.match(/\(.*?\)/gi) || '()')[0] : `(${argsStr})`;
    const args = argsStr
        .replace(/[()]/g, '')
        .split(',')
        .filter((e) => e !== '');
    const typedArgs = args.map((arg) => {
        let [name] = arg.split('=');
        name = name.trim();
        if (name.includes('[')) {
            const nakedName = name.replace(/\[|\]/gi, '').trim();
            name = `${nakedName}Array`;
            return `${name}: any`;
        }
        if (name.includes('{')) {
            const nakedName = name.replace(/\{|\}/gi, '').trim();
            name = `${nakedName}Object: {${nakedName}: any}`;
            return `${name}`;
        }
        if (name.includes('...')) {
            name = `${name}Array: any[]`;
            return `${name}`;
        }
        return `${name}: any`;
    });
    return `(${typedArgs}) => any`;
}
function getObjectTypes(obj, nest) {
    const keys = Object.keys(obj).sort();
    if (keys.length === 0) {
        return '{}';
    }
    const keyValuePairs = keys.map((key) => `${escapeSpecialKey(key)}: ${getTypeName(obj[key], nest + 1)}`);
    return `{ ${keyValuePairs.join(', ')} }`;
}
function escapeSpecialKey(key) {
    const hasSpecialCharacters = !key.match(/^[a-z0-9_]+$/i);
    if (hasSpecialCharacters) {
        return JSON.stringify(key);
    }
    return key;
}
const logs = {};
const trackedObjects = new WeakMap();
function $_$twiz(name, value, pos, filename, optsJson) {
    const opts = JSON.parse(optsJson);
    const objectDeclaration = trackedObjects.get(value);
    const index = JSON.stringify({ filename, pos, opts });
    try {
        const typeName = getTypeName(value);
        if (!logs[index]) {
            logs[index] = new Set();
        }
        const typeSpec = JSON.stringify([typeName, objectDeclaration]);
        logs[index].add(typeSpec);
    }
    catch (e) {
        if (e instanceof NestError) {
            // simply ignore the type
            return;
        }
        throw e;
    }
}
exports.$_$twiz = $_$twiz;
// tslint:disable:no-namespace
(function ($_$twiz) {
    $_$twiz.typeName = getTypeName;
    $_$twiz.get = () => {
        return Object.keys(logs).map((key) => {
            const { filename, pos, opts } = JSON.parse(key);
            const typeOptions = Array.from(logs[key]).map((v) => JSON.parse(v));
            return [filename, pos, typeOptions, opts];
        });
    };
    $_$twiz.track = (value, filename, offset) => {
        if (value && (typeof value === 'object' || typeof value === 'function')) {
            trackedObjects.set(value, [filename, offset]);
        }
        return value;
    };
})($_$twiz = exports.$_$twiz || (exports.$_$twiz = {}));
//# sourceMappingURL=type-collector-snippet.js.map