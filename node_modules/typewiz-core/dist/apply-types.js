"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const ts = require("typescript");
const compiler_helper_1 = require("./compiler-helper");
const replacement_1 = require("./replacement");
const typewiz_error_1 = require("./typewiz-error");
function findType(program, typeName, sourcePos) {
    if (program && sourcePos) {
        const [sourceName, sourceOffset] = sourcePos;
        const typeChecker = program.getTypeChecker();
        let foundType = null;
        function visit(node) {
            if (node.getStart() === sourceOffset) {
                const type = typeChecker.getTypeAtLocation(node);
                foundType = typeChecker.typeToString(type);
            }
            ts.forEachChild(node, visit);
        }
        const sourceFile = program.getSourceFile(sourceName);
        if (!sourceFile) {
            throw new typewiz_error_1.TypewizError(`File not found: ${sourceName}`);
        }
        visit(sourceFile);
        if (foundType && foundType !== 'any') {
            return foundType;
        }
    }
    return typeName;
}
function applyTypesToFile(source, typeInfo, options, program) {
    const replacements = [];
    const prefix = options.prefix || '';
    for (const [, pos, types, opts] of typeInfo) {
        const isOptional = source[pos - 1] === '?';
        let sortedTypes = types
            .map(([name, sourcePos]) => findType(program, name, sourcePos))
            .filter((t) => t)
            .sort();
        if (isOptional) {
            sortedTypes = sortedTypes.filter((t) => t !== 'undefined');
        }
        if (sortedTypes.length === 0) {
            continue;
        }
        let thisPrefix = '';
        let suffix = '';
        if (opts && opts.parens) {
            replacements.push(replacement_1.Replacement.insert(opts.parens[0], '('));
            suffix = ')';
        }
        if (opts && opts.thisNeedsComma) {
            suffix = ', ';
        }
        if (opts && opts.thisType) {
            thisPrefix = 'this';
        }
        replacements.push(replacement_1.Replacement.insert(pos, thisPrefix + ': ' + prefix + sortedTypes.join('|') + suffix));
    }
    return replacement_1.applyReplacements(source, replacements);
}
exports.applyTypesToFile = applyTypesToFile;
function applyTypes(typeInfo, options = {}) {
    const files = {};
    const program = compiler_helper_1.getProgram(options);
    for (const entry of typeInfo) {
        const file = entry[0];
        if (!files[file]) {
            files[file] = [];
        }
        files[file].push(entry);
    }
    for (const file of Object.keys(files)) {
        const filePath = options.rootDir ? path.join(options.rootDir, file) : file;
        const source = fs.readFileSync(filePath, 'utf-8');
        fs.writeFileSync(filePath, applyTypesToFile(source, files[file], options, program));
    }
}
exports.applyTypes = applyTypes;
//# sourceMappingURL=apply-types.js.map